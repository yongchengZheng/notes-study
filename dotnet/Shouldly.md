# 基概

* `Shoudly`是一个断言框架 
* 相比于使用`Assert`，`Shoudly`提供了一种更为自然、更易读的方式来编写测试断言
  * 其自动生成的错误信息更加直观和人性化，使得测试时的错误信息更易于理解
  * 并提供了大量的断言方法，涵盖了对集合的内容、顺序的检查，支持更为丰富的测试场景
  * 且使用了链式调用和扩展方法，使得断言语句读起来更像是自然语言
  * 还支持对异步代码的支持，可以直接对`Task`的结果进行断言

# 注意事项

* `Shouldly`的使用很简单，并且官方文档也描述的很详细易懂
* 这里就不搬迁用法了，只讲一些要注意的点



* **当调用诸如`ShouldBe()`、`ShouldBeOneOf()`等方法进行判断时，是通过调用它们的`.Equal()`方法做判断逻辑的，这意味着比较的基础是对象的相等性逻辑，该逻辑可以被重写以适应特定的比较需求**



* **对于`ShouldBeAssignableTo<T>()`,其目的在于判断对象实例是否可以被分配给指定的类型`T`,也就是说此对象实例所在类需满足继承了`T`类或者实现了`T`接口**
* **而对于`ShouldBeOfType<T>()`，则指明此实例对象必须就是这个具体的类型，不能是其他的**



* **当调用`ShouldBeGreaterThan()`、`ShouldBeLessThan`、`ShouldBeInRange()`等方法进行比较大小操作时，适用于任何实现了`IComparable`接口的类**



* **当调用 `ShouldBe()` 方法来比较两个 `IEnumerable` 类型（如列表、数组等）时，它默认期望两个集合中的元素不仅相等，而且它们的顺序也必须完全一致。这意味着，如果元素的内容相同，但顺序不同，`ShouldBe` 将会认为这两个集合不相等，并导致测试失败**



* **在使用 `ShouldContainWithoutWhitespace()` 断言时，Shouldly 框架会先从两个字符串——调用者（即包含断言的字符串）和被调用者（即作为参数传入的字符串，预期被包含的字符串）——中移除所有空白字符。这包括空格、制表符、换行符等。完成这一步骤后，框架会比较处理后的字符串，以判断无空白字符的条件下，被调用者字符串是否被调用者字符串包含**



* `ShouldBeSubsetOf()`的断言规则
  * **不考虑元素的顺序**
  * **如果被测试的集合是空的，它也会被认为是任何集合的子集，包括空集合自身**
  * **用于验证所有被测试集合中的元素都出现在另一个集合中，但不要求这两个集合完全相等**



* 对于`ShouldMatchApproved()`
  * **其作用在于将当前测试输出与先前批准的、已知为正确的输出（`approved`文件）进行比较，如果当前输出与预期的输出匹配，则测试通过，否则测试失败**
  * 常见的应用场景比如说验证`API`或服务的响应体是否和预期的`Json`结构数据匹配
  * 其工作原理为：
    * **测试执行时生成的输出，与此输出同名但扩展名为`.approved`的文件中的预期输出进行比较**
      * **如果`approved`文件不存在，则测试失败，并生成一个`.reveived`文件装载此次的测试输出**
      * **如果存在`approved`文件，但存在差异，测试也会失败，并更新到`.received`文件（覆盖操作）以反映最新的输出**
    * **测试失败后，后续开发者需检查`.reveived`文件，确认输出是否正确，如果正确，则将`.reveived`文件重命名为`.approved`文件，这样此文件就成为了未来测试的基准**



